<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="stylesheet" href="styles.css">
  <meta name="theme-color" content="#00e0e0">
  <title>Scorekeeper</title>
</head>

<body>
  <div class="app" id="app">
    <header>
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <div>
          <div style="font-weight:800" id="titleEditable">New Game</div>
          <div class="muted small" id="createdAt">‚Äî</div>
        </div>
      </div>
      <div class="title">
        <button id="gamesMenuBtn" class="menu-btn" title="Open games menu" hidden>üè∑Ô∏è <span id="currentGameTitle">New
            Game</span></button>
      </div>
      <div class="controls">
        <div class="menu-wrap">
          <button id="menuBtn" class="btn" style="font-size:1.2em;">‚ò∞</button>
          <div id="menuDropdown" class="menu-dropdown hidden">
            <div class="menu-item" id="menuGames">Games</div>
            <div class="menu-item" id="menuPlayers">Players</div>
            <div class="menu-item" id="menuReset">Reset</div>
            <div class="menu-item has-submenu" id="menuShare">
              Share
              <div class="menu-dropdown submenu hidden" id="submenuShare">
                <div class="menu-item" data-share="image">Image</div>
                <div class="menu-item" data-share="fixed">Text</div>
                <div class="menu-item" data-share="markdown">Markdown</div>
                <div class="menu-item" data-share="csv">CSV</div>
              </div>
            </div>
            <div class="menu-item" id="menuTemplates">Templates</div>
          </div>
        </div>
      </div>
    </header>

    <section id="gameCard" class="not-card">
      <div id="gameArea">
        <!-- Dynamic content -->
        <div class="muted">No game selected. Create one from the menu.</div>
      </div>
    </section>
  </div>

  <!-- Modals -->
  <div id="modalGames" class="modal-back">
    <div class="modal">
      <h3>Games</h3>
      <div class="new-game-controls">
        <div class="new-game-row">
          <input id="newGameTitle" class="text-input" placeholder="Title" />
          <select id="newGameType" class="text-input">
            <option value="Standard">Standard</option>
            <option value="Tally">Tally</option>
            <option value="Fixed">Fixed</option>
          </select>
        </div>
        <div class="new-game-row">
          <select id="newGameTemplate" class="text-input hidden"></select>
          <button id="createGameBtn" class="btn">Create</button>
        </div>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;align-items:center">
        <div class="muted-2">Ongoing games:</div>
        <div id="gamesList" style="flex:1;overflow:auto;max-height:440px"></div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="closeGames" class="menu-btn">Close</button>
      </div>
    </div>
  </div>

  <div id="modalTemplates" class="modal-back">
    <div class="modal">
      <h3>Templates (Fixed)</h3>
      <div class="field">
        <label class="small">Existing templates</label>
        <div id="templatesContainer" class="template-list"></div>
      </div>
      <div class="field">
        <label class="small">Create / Edit template (name & comma-separated labels)</label>
        <input id="tplName" class="text-input" placeholder="Generala" />
        <input id="tplLabels" class="text-input" placeholder="1,2,3,4,5,6,E,F,P,G,DG" />
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="saveTpl" class="btn">Save template</button>
        </div>
      </div>
      <div style="display:flex;justify-content:flex-end">
        <button id="closeTpl" class="menu-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- Confirmation modal -->
  <div id="modalConfirm" class="modal-back">
    <div class="modal">
      <h3 id="confirmTitle">Confirm</h3>
      <div id="confirmText" class="muted small" style="margin-bottom:12px"></div>
      <div style="display:flex;justify-content:flex-end;gap:8px">
        <button id="confirmCancel" class="menu-btn">Cancel</button>
        <button id="confirmOk" class="btn">OK</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>

    // --------------------------- PWA ---------------------------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }

    // --------------------------- Persistence ---------------------------
    const STORAGE_KEYS = {
      active: 'sk_active_v1',
      games: 'sk_games_v1',
      templates: 'sk_templates_v1'
    };

    function loadJSON(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        return JSON.parse(raw);
      } catch (e) { return fallback; }
    }
    function saveJSON(key, obj) { localStorage.setItem(key, JSON.stringify(obj)); }

    const DEFAULT_TEMPLATES = {
      "Generala": ['1', '2', '3', '4', '5', '6', 'E', 'F', 'P', 'G', 'DG'],
      "Carioca": ['2P', '1P1E', '2E', '3P', '2P1E', '1P2E', '3E', '4P'],
      "Yatzee": ['1', '2', '3', '4', '5', '6', 'TK', 'FK', 'FH', 'SS', 'LS', 'YZ', 'CH', 'Y2']
    };

    let activeGameId = loadJSON(STORAGE_KEYS.active, null);
    let games = loadJSON(STORAGE_KEYS.games, []);
    let templates = loadJSON(STORAGE_KEYS.templates, DEFAULT_TEMPLATES);

    // ensure sane structure
    if (!Array.isArray(games)) games = [];
    saveAll();

    function saveAll() {
      saveJSON(STORAGE_KEYS.games, games);
      saveJSON(STORAGE_KEYS.templates, templates);
      saveJSON(STORAGE_KEYS.active, activeGameId);
    }

    // --------------------------- Utilities ---------------------------
    function uid(prefix = 'id') { return prefix + '_' + Math.random().toString(36).slice(2, 9); }
    function formatDateISO(date) { // dd/mm/yyyy
      const d = new Date(date);
      return String(d.getDate()).padStart(2, '0') + '/' + String(d.getMonth() + 1).padStart(2, '0') + '/' + d.getFullYear();
    }
    function formatDateForStore() { return (new Date()).toISOString(); }

    // find active game index
    function findGame(id) { return games.find(g => g.id === id); }
    function setActiveGame(id) {
      activeGameId = id;
      renderApp();
      saveAll();
    }

    // --------------------------- Initial UI wiring ---------------------------
    const gamesMenuBtn = document.getElementById('gamesMenuBtn');
    const modalGames = document.getElementById('modalGames');
    const closeGames = document.getElementById('closeGames');
    const gamesListDiv = document.getElementById('gamesList');
    const newGameTitle = document.getElementById('newGameTitle');
    const newGameType = document.getElementById('newGameType');
    const createGameBtn = document.getElementById('createGameBtn');
    const newGameTemplate = document.getElementById('newGameTemplate');

    const menuGames = document.getElementById('menuGames');
    const modalTemplates = document.getElementById('modalTemplates');
    const menuTemplates = document.getElementById('menuTemplates');
    const closeTpl = document.getElementById('closeTpl');
    const templatesContainer = document.getElementById('templatesContainer');
    const tplName = document.getElementById('tplName');
    const tplLabels = document.getElementById('tplLabels');
    const saveTpl = document.getElementById('saveTpl');

    const menuPlayers = document.getElementById('menuPlayers');
    const menuReset = document.getElementById('menuReset');
    const menuShare = document.getElementById('menuShare');
    const submenuShare = document.getElementById("submenuShare");
    const titleEditable = document.getElementById('titleEditable');
    const createdAtEl = document.getElementById('createdAt');
    const currentGameTitle = document.getElementById('currentGameTitle');
    const gameArea = document.getElementById('gameArea');
    const templatesSelector = newGameTemplate;

    // confirm modal
    const modalConfirm = document.getElementById('modalConfirm');
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmText = document.getElementById('confirmText');
    const confirmOk = document.getElementById('confirmOk');
    const confirmCancel = document.getElementById('confirmCancel');

    // wire events
    gamesMenuBtn.addEventListener('click', () => { openGamesModal(); });
    closeGames.addEventListener('click', () => { closeModal(modalGames); });
    closeTpl.addEventListener('click', () => { closeModal(modalTemplates); });

    newGameType.addEventListener('change', (e) => {
      if (e.target.value === 'Fixed') { newGameTemplate.classList.remove('hidden'); populateTemplatesSelector(); }
      else newGameTemplate.classList.add('hidden');
    });

    createGameBtn.addEventListener('click', () => {
      const title = newGameTitle.value.trim() || 'Game ' + (games.length + 1);
      const type = newGameType.value;
      const id = uid('g');
      const createdAt = formatDateForStore();
      let game = { id, title, type, createdAt, players: [], rounds: [] };
      if (type === 'Tally') { game.tally = []; } // integer scores per player
      if (type === 'Fixed') {
        game.template = (newGameTemplate.value || Object.keys(templates)[0] || null);
        // rows: array of objects per label with player values null
        const labels = templates[game.template] || [];
        game.rows = labels.map(l => ({ label: l, vals: [] }));
      }
      games.unshift(game);
      saveAll();
      newGameTitle.value = '';
      setActiveGame(id);
      closeModal(modalGames);
    });

    function openGamesModal() {
      modalGames.style.display = 'flex';
      renderGamesList();
      if (newGameType.value === 'Fixed') populateTemplatesSelector();
    }

    function renderGamesList() {
      gamesListDiv.innerHTML = '';
      if (games.length === 0) { gamesListDiv.innerHTML = '<div class="muted small">No games yet.</div>'; return; }
      games.forEach(g => {
        const el = document.createElement('div');
        el.className = 'card';
        el.style.marginBottom = '8px';
        el.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <div style="padding-right:8px;max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">
          <div style="font-weight:700">${escapeHtml(g.title)}</div>
          <div class="muted small">${g.type === 'Fixed' && g.template ? escapeHtml(g.template) : g.type} ‚Ä¢ ${formatDateISO(g.createdAt)}</div>
        </div>
        <div style="display:flex;gap:6px;align-items:center">
          <button class="menu-btn btn-open" data-id="${g.id}">Open</button>
          <button class="menu-btn btn-clear" data-id="${g.id}">Clear</button>
          <button class="menu-btn btn-delete" data-id="${g.id}">Delete</button>
        </div>
      </div>
    `;
        gamesListDiv.appendChild(el);
      });
      // bind
      gamesListDiv.querySelectorAll('.btn-open').forEach(b => b.addEventListener('click', e => { const id = e.target.dataset.id; setActiveGame(id); saveAll(); closeModal(modalGames); }));
      gamesListDiv.querySelectorAll('.btn-clear').forEach(b => b.addEventListener('click', e => {
        const id = e.target.dataset.id;
        resetGame(id);
        renderGamesList();
      }));
      gamesListDiv.querySelectorAll('.btn-delete').forEach(b => b.addEventListener('click', e => {
        const id = e.target.dataset.id;
        confirmDialog('Delete game', 'Permanently delete this game?', () => {
          games = games.filter(x => x.id !== id);
          if (activeGameId === id) activeGameId = null;
          saveAll();
          renderGamesList();
          renderApp();
        });
      }));
    }

    function resetGame(id) {
      confirmOk.style.display = 'inline-block';
      confirmCancel.style.display = 'inline-block';
      confirmDialog('Clear scores', 'This will reset scores and update the creation date for the selected game. Continue?', () => {
        const g = findGame(id);
        if (!g) return;
        g.createdAt = formatDateForStore();
        
        if (g.type === 'Standard') g.rounds = [];
        
        if (g.type === 'Tally') {
          g.tally = g.players.map(() => 0);
        }
        
        if (g.type === 'Fixed') {
          // Set all player values in every row to null (empty)
          g.rows.forEach(r => {
            r.vals = g.players.map(() => null);
          });
        }
        
        saveAll();
        if (activeGameId === id) renderApp();
      });
    }

    function populateTemplatesSelector() {
      templatesSelector.innerHTML = '';
      Object.keys(templates).forEach(k => {
        const opt = document.createElement('option');
        opt.value = k; opt.textContent = k;
        templatesSelector.appendChild(opt);
      });
      if (Object.keys(templates).length === 0) {
        templatesSelector.innerHTML = '<option value="">(no templates)</option>';
      }
    }

    // Templates modal
    function openTemplatesModal() {
      confirmTitle.textContent = 'Templates';
      renderTemplates();
      modalConfirm.style.display = 'flex';
      confirmCancel.style.display = 'none';
      confirmOk.onclick = () => { modalConfirm.style.display = 'none'; };
    }

    function renderTemplates() {
      const keys = Object.keys(templates);
      
      const listHtml = keys.map(k => `
        <div style="padding:10px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <div style="flex-grow:1; overflow:hidden; margin-right:8px;">
            <div style="font-size:1rem; font-weight:bold;">${escapeHtml(k)}</div>
            <div class="muted" style="font-size:0.75rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
              ${templates[k].join(', ')}
            </div>
          </div>
          <div style="display:flex; gap:6px;">
            <button class="menu-btn edit-template" data-name="${escapeHtml(k)}">Edit</button>
            <button class="menu-btn remove-template" data-name="${escapeHtml(k)}" style="color:var(--danger)">‚úï</button>
          </div>
        </div>
      `).join('');

      confirmText.innerHTML = `
        <div style="max-height:300px; overflow-y:auto; margin-bottom:12px; border:1px solid var(--border-color); border-radius:8px;">
          ${listHtml || '<p class="muted" style="padding:10px">No templates found.</p>'}
        </div>
        <div style="display:flex; flex-direction:column; gap:8px;">
          <button id="addNewTemplateBtn" class="btn" style="width:100%">‚ûï Add New Template</button>
          <button id="restoreDefaultsBtn" class="btn" style="width:100%; background:var(--muted); color:var(--bg-color); font-size:0.9rem;">üîÑ Restore Defaults</button>
        </div>
      `;

      // --- ADD NEW TEMPLATE ---
      document.getElementById('addNewTemplateBtn').onclick = () => {
        const name = prompt("Enter template name:");
        if (name && name.trim()) {
          const trimmedName = name.trim();
          if (templates[trimmedName]) {
            alert("A template with that name already exists.");
          } else {
            templates[trimmedName] = []; // Start empty
            saveJSON(STORAGE_KEYS.templates, templates);
            renderTemplates();
          }
        }
      };

      // --- EDIT TEMPLATE (Text-Mode per entity) ---
      confirmText.querySelectorAll('.edit-template').forEach(btn => {
        btn.onclick = () => {
          const name = btn.dataset.name;
          const currentRows = templates[name].join(', ');
          
          confirmText.innerHTML = `
            <div style="margin-bottom:10px;">
              <label>Editing Rows for: <strong>${escapeHtml(name)}</strong></label>
              <textarea id="rowsEditor" class="text-input" 
                        style="width:100%; height:140px; margin-top:8px; font-family:monospace;" 
                        placeholder="Enter labels separated by commas (e.g. 1, 2, 3, Total)">${escapeHtml(currentRows)}</textarea>
              <p class="small muted" style="margin-top:4px;">Separate items with commas.</p>
            </div>
            <div style="display:flex; gap:8px;">
              <button id="saveRowBtn" class="btn" style="flex:1">Save</button>
              <button id="cancelRowBtn" class="btn" style="flex:1; background:var(--muted);">Back</button>
            </div>
          `;

          document.getElementById('saveRowBtn').onclick = () => {
            const input = document.getElementById('rowsEditor').value;
            // Split by comma, trim whitespace, remove empty strings
            templates[name] = input.split(',').map(s => s.trim()).filter(s => s !== "");
            saveJSON(STORAGE_KEYS.templates, templates);
            renderTemplates();
          };

          document.getElementById('cancelRowBtn').onclick = () => renderTemplates();
        };
      });

      // --- REMOVE TEMPLATE ---
      confirmText.querySelectorAll('.remove-template').forEach(btn => {
        btn.onclick = () => {
          const name = btn.dataset.name;
          confirmDialog('Delete Template', `Delete "${name}"?`, () => {
            delete templates[name];
            saveJSON(STORAGE_KEYS.templates, templates);
            renderTemplates();
          });
        };
      });

      // --- RESTORE DEFAULTS ---
      document.getElementById('restoreDefaultsBtn').onclick = () => {
        confirmDialog('Restore Defaults', 'This will reset templates to the original list. Custom ones will be lost. Continue?', () => {
          templates = JSON.parse(JSON.stringify(DEFAULT_TEMPLATES));
          saveJSON(STORAGE_KEYS.templates, templates);
          renderTemplates();
        });
      };
    }

    saveTpl.addEventListener('click', () => {
      const name = tplName.value.trim();
      const labels = tplLabels.value.split(',').map(s => s.trim()).filter(Boolean);
      if (!name) { alert('Provide a template name.'); return; }
      templates[name] = labels;
      saveAll();
      tplName.value = ''; tplLabels.value = '';
      renderTemplates();
      populateTemplatesSelector();
    });

    // confirm dialog helper
    function confirmDialog(title, text, onOk) {
      confirmTitle.textContent = title;
      confirmText.textContent = text;
      modalConfirm.style.display = 'flex';
      confirmOk.onclick = () => {
        modalConfirm.style.display = 'none';
        onOk && onOk();
      };
      confirmCancel.onclick = () => modalConfirm.style.display = 'none';
    }

    // close modal
    function closeModal(el) { el.style.display = 'none'; }

    // --------------------------- Game area rendering & interactions ---------------------------
    function renderApp() {

      const g = activeGameId ? findGame(activeGameId) : null;
      if (!g) {
        currentGameTitle.textContent = 'New Game';
        titleEditable.textContent = 'No game selected';
        createdAtEl.textContent = 'Created: ‚Äî';
        gameArea.innerHTML = `<div class="muted">Open the <strong>Games</strong> menu to create a new game or open an existing one.</div>`;
        return;
      }

      // Migration: Convert old string players to objects
      g.players = g.players.map(p => typeof p === 'string' ? { name: p, hidden: false } : p);

      currentGameTitle.textContent = g.title;
      titleEditable.textContent = g.title;
      createdAtEl.textContent = formatDateISO(g.createdAt) + (g.type === 'Fixed' && g.template ? ' (' + g.template + ')' : '');

      // allow renaming title inline
      titleEditable.contentEditable = true;
      titleEditable.onblur = () => {
        const newTitle = titleEditable.textContent.trim() || 'Untitled';
        g.title = newTitle;
        currentGameTitle.textContent = newTitle;
        saveAll();
        renderGamesList();
      };

      if (g.type === 'Standard') renderStandard(g);
      else if (g.type === 'Tally') renderTally(g);
      else if (g.type === 'Fixed') renderFixed(g);
      else gameArea.innerHTML = '<div class="muted">Unsupported type</div>';
      saveAll();
    }

    function addPlayerToGame(game, name) {
      if (!name) return;
      const newPlayer = { name: name.trim(), hidden: false };
      game.players.push(newPlayer);
      
      if (game.type === 'Standard') {
        game.rounds.forEach(r => { r[newPlayer.name] = 0; });
      } else if (game.type === 'Tally') {
        if (!game.tally) game.tally = [];
        game.tally.push(0);
      } else if (game.type === 'Fixed') {
        // Add a null entry for the new player in every existing row
        game.rows.forEach(r => r.vals.push(null));
      }
      saveAll();
    }

    // remove player
    function removePlayerFromGame(game, idx) {
      const name = game.players[idx];
      confirmDialog('Remove player', `Remove "${name}" from the game? This will remove all their values.`, () => {
        game.players.splice(idx, 1);
        if (game.type === 'Standard') {
          game.rounds.forEach(r => delete r[name]);
        } else if (game.type === 'Tally') {
          game.tally.splice(idx, 1);
        } else if (game.type === 'Fixed') {
          game.rows.forEach(r => { r.vals.splice(idx, 1); });
        }
        if (game.players.length === 0) {
          // clear some data if no players
        }
        saveAll();
        renderApp();
      });
    }

    function openPlayersModal(g) {
      g.players = g.players.map(p => typeof p === 'string' ? { name: p, hidden: false } : p);

      const pls = g.players.map((p, i) => `
        <div style="display:flex;justify-content:space-between;align-items:center;padding:8px;border-bottom:1px solid var(--border-color)">
          <div class="player-name-edit ${p.hidden ? 'player-hidden' : ''}" data-idx="${i}" 
              style="cursor:pointer; flex-grow:1; font-size: .9rem; font-weight: 400;">
            ${p.hidden ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üë§'} ${escapeHtml(p.name)}
          </div>
          <div style="display:flex; gap:4px;">
            <button class="menu-btn toggle-hide" data-idx="${i}">${p.hidden ? 'Show' : 'Hide'}</button>
            <button class="menu-btn remove-player" data-idx="${i}">Remove</button>
          </div>
        </div>`).join('');

      confirmTitle.textContent = 'Players';
      confirmText.innerHTML = `<div style="max-height:240px;overflow:auto">${pls}</div><div style="margin-top:12px"><button id="addPlayerBtn" class="btn" style="width:100%">‚ûï Add Player</button></div>`;
      modalConfirm.style.display = 'flex';
      confirmCancel.style.display = 'none';
      confirmOk.onclick = () => { modalConfirm.style.display = 'none'; };

      // Rename Logic
      confirmText.querySelectorAll('.player-name-edit').forEach(el => {
        el.onclick = () => {
          const idx = Number(el.dataset.idx);
          const newNm = prompt('Rename player:', g.players[idx].name);
          if (newNm && newNm.trim() && newNm !== g.players[idx].name) {
            const oldName = g.players[idx].name;
            g.players[idx].name = newNm.trim();
            if (g.type === 'Standard') {
              g.rounds.forEach(r => { r[g.players[idx].name] = r[oldName]; delete r[oldName]; });
            }
            saveAll(); renderApp(); openPlayersModal(g);
          }
        };
      });

      // Toggle Hide Logic
      confirmText.querySelectorAll('.toggle-hide').forEach(b => {
        b.onclick = (e) => {
          const idx = Number(e.target.dataset.idx);
          g.players[idx].hidden = !g.players[idx].hidden;
          saveAll(); renderApp(); openPlayersModal(g);
        };
      });

      // Add/Remove Logic
      document.getElementById('addPlayerBtn').onclick = () => {
        const n = prompt('Name:'); if (n) { addPlayerToGame(g, n); renderApp(); openPlayersModal(g); }
      };
      confirmText.querySelectorAll('.remove-player').forEach(b => {
        b.onclick = (e) => { modalConfirm.style.display = 'none'; removePlayerFromGame(g, Number(e.target.dataset.idx)); };
      });
    }

    // ---------- Standard ----------
    function renderStandard(g) {
      g.rounds = g.rounds || [];
      // Migration for safety
      g.players = g.players.map(p => typeof p === 'string' ? { name: p, hidden: false } : p);
      
      // Filter for visible players
      const visiblePlayers = g.players.filter(p => !p.hidden);
      
      const table = document.createElement('div');
      table.innerHTML = `<div class="table-wrap"><table id="stdTable"><thead></thead><tbody></tbody><tfoot></tfoot></table></div>`;
      gameArea.innerHTML = '';
      gameArea.appendChild(table);

      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      const tfoot = table.querySelector('tfoot');

      // Header
      const ths = document.createElement('tr');
      ths.innerHTML = `<th class="round-num">#</th>` + 
        visiblePlayers.map(p => `<th>${escapeHtml(p.name)}</th>`).join('') + 
        `<th style="width:40px"></th>`;
      thead.appendChild(ths);

      // Rows
      tbody.innerHTML = '';
      g.rounds.forEach((r, idx) => {
        const tr = document.createElement('tr');
        const roundNum = `<td class="round-num">${String(idx + 1).padStart(5, ' ')}</td>`;
        const cells = visiblePlayers.map(p => {
          const val = r[p.name] === undefined || r[p.name] === null ? '' : String(r[p.name]);
          return `<td class="input-cell"><input type="text" class="cell" data-player="${escapeHtml(p.name)}" data-row="${idx}" value="${escapeHtml(val)}"/></td>`;
        }).join('');
        const remove = `<td><button class="remove-row" data-row="${idx}">-</button></td>`;
        tr.innerHTML = roundNum + cells + remove;
        tbody.appendChild(tr);
      });

      // Footer: totals
      const totals = visiblePlayers.map(p => {
        let s = 0;
        g.rounds.forEach(r => {
          const v = r[p.name];
          const n = (v === null || v === '' || v === undefined) ? 0 : Number(v) || 0;
          s += n;
        });
        return s;
      });
      tfoot.innerHTML = `<tr class="total-row"><td class="round-num">T</td>` + 
        totals.map(t => `<td>${String(t).padStart(5, ' ')}</td>`).join('') + 
        `<td><button id="addRowButton" class="add-row">+</button></td></tr>`;

      // Bindings
      document.getElementById('addRowButton').onclick = () => {
        const newR = {};
        g.players.forEach(p => newR[p.name] = 0);
        g.rounds.push(newR);
        saveAll();
        renderApp();
        setTimeout(() => {
          const last = document.querySelector(`input.cell[data-row="${g.rounds.length - 1}"]`);
          last && last.focus();
        }, 60);
      };

      tbody.querySelectorAll('.remove-row').forEach(b => {
        b.onclick = (e) => {
          const index = Number(e.target.dataset.row);
          confirmDialog('Remove round', `Remove round ${index + 1}?`, () => {
            g.rounds.splice(index, 1);
            saveAll();
            renderApp();
          });
        };
      });

      tbody.querySelectorAll('input.cell').forEach(inp => {
        inp.onblur = (e) => {
          const el = e.target;
          const row = Number(el.dataset.row);
          const playerName = el.dataset.player;
          const raw = el.value.trim();
          g.rounds[row][playerName] = (raw === '') ? '' : (Number.isFinite(Number(raw)) ? Number(raw) : raw);
          saveAll();
          renderApp();
        };
        inp.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); inp.blur(); } };
      });

      menuPlayers.onclick = () => openPlayersModal(g);
      menuReset.onclick = () => resetGame(g.id);
    }

    // ---------- Tally ----------
    function renderTally(g) {
      g.players = g.players.map(p => typeof p === 'string' ? { name: p, hidden: false } : p);
      g.tally = g.tally || g.players.map(() => 0);
      
      const wrap = document.createElement('div');
      wrap.innerHTML = `<div class="tally-grid" id="tallyGrid"></div>`;
      gameArea.innerHTML = '';
      gameArea.appendChild(wrap);
      const grid = document.getElementById('tallyGrid');

      const visiblePlayers = g.players.map((p, i) => ({ ...p, originalIdx: i })).filter(p => !p.hidden);
      const maxSets = Math.max(1, ...visiblePlayers.map(p => Math.ceil(g.tally[p.originalIdx] / 5)), 6);

      visiblePlayers.forEach((p) => {
        const plWrap = document.createElement('div'); 
        plWrap.className = 'tally-player card'; 
        plWrap.style.padding = '8px';
        plWrap.innerHTML = `
          <div class="tally-name">${escapeHtml(p.name)}</div>
          <div class="tally-squares" id="player-${p.originalIdx}"></div>
          <div class="controls-row">
            <button class="menu-btn plus" data-idx="${p.originalIdx}">Ôºã</button>
            <button class="menu-btn minus" data-idx="${p.originalIdx}">Ôºç</button>
          </div>`;
        grid.appendChild(plWrap);

        const container = plWrap.querySelector('.tally-squares');
        for (let s = 0; s < maxSets; s++) {
          const sq = document.createElement('div');
          sq.className = 'sq';
          sq.innerHTML = '<div class="seg seg-left hidden"></div><div class="seg seg-top hidden"></div><div class="seg seg-right hidden"></div><div class="seg seg-bottom hidden"></div><div class="seg seg-diag hidden"></div>';
          container.appendChild(sq);
        }
        
        // Fill segments
        let score = g.tally[p.originalIdx] || 0;
        const cells = container.querySelectorAll('.sq');
        for (let s = 0; s < cells.length && score > 0; s++) {
          const fill = Math.min(5, score);
          const cell = cells[s];
          if (fill >= 1) cell.querySelector('.seg-left').classList.remove('hidden');
          if (fill >= 2) cell.querySelector('.seg-top').classList.remove('hidden');
          if (fill >= 3) cell.querySelector('.seg-right').classList.remove('hidden');
          if (fill >= 4) cell.querySelector('.seg-bottom').classList.remove('hidden');
          if (fill >= 5) cell.querySelector('.seg-diag').classList.remove('hidden');
          score -= fill;
        }
      });

      grid.querySelectorAll('.plus').forEach(b => {
        b.onclick = (e) => {
          const idx = Number(e.target.dataset.idx);
          g.tally[idx]++;
          saveAll(); renderApp();
        };
      });
      grid.querySelectorAll('.minus').forEach(b => {
        b.onclick = (e) => {
          const idx = Number(e.target.dataset.idx);
          g.tally[idx] = Math.max(0, g.tally[idx] - 1);
          saveAll(); renderApp();
        };

        // click anywhere on squares to add score
        grid.querySelectorAll('.tally-squares').forEach(container => {
        container.onclick = () => {
            // Extract the original index from the element's ID (e.g., "player-2")
            const playerIdx = Number(container.id.replace('player-', ''));
            g.tally[playerIdx] = (g.tally[playerIdx] || 0) + 1;
            saveAll(); //
            renderApp(); //
        };
        });
      });

      menuPlayers.onclick = () => openPlayersModal(g);
      menuReset.onclick = () => resetGame(g.id);
    }

    // ---------- Fixed ----------
    function renderFixed(g) {
      g.players = g.players.map(p => typeof p === 'string' ? { name: p, hidden: false } : p);
      const visiblePlayers = g.players.map((p, i) => ({ ...p, originalIdx: i })).filter(p => !p.hidden);
      
      const table = document.createElement('div');
      table.innerHTML = `<div class="table-wrap"><table id="fixedTable"><thead></thead><tbody></tbody><tfoot></tfoot></table></div>`;
      gameArea.innerHTML = '';
      gameArea.appendChild(table);
      const tbody = table.querySelector('tbody');

      // Header
      const ths = document.createElement('tr');
      ths.innerHTML = `<th class="label-left"></th>` + 
        visiblePlayers.map(p => `<th>${escapeHtml(p.name)}</th>`).join('') + `<th></th>`;
      table.querySelector('thead').appendChild(ths);

      // Rows
      g.rows.forEach((row, ridx) => {
        const tr = document.createElement('tr');
        const cells = visiblePlayers.map((p) => {
          const val = (row.vals[p.originalIdx] == null) ? '' : String(row.vals[p.originalIdx]);
          return `<td class="input-cell"><input type="text" class="cell" data-row="${ridx}" data-col="${p.originalIdx}" value="${escapeHtml(val)}"/></td>`;
        }).join('');
        tr.innerHTML = `<td class="label-left">${escapeHtml(row.label)}</td>` + cells + `<td></td>`;
        tbody.appendChild(tr);
      });

      // Footer totals
      const totals = visiblePlayers.map((p) => {
        let s = 0;
        g.rows.forEach(r => s += (Number(r.vals[p.originalIdx]) || 0));
        return s;
      });
      table.querySelector('tfoot').innerHTML = `<tr class="total-row"><td class="label-left">T</td>` + 
        totals.map(t => `<td>${t}</td>`).join('') + `<td></td></tr>`;

      tbody.querySelectorAll('input.cell').forEach(inp => {
        inp.onblur = (e) => {
          const r = Number(e.target.dataset.row), c = Number(e.target.dataset.col), raw = e.target.value.trim();
          g.rows[r].vals[c] = (raw === '') ? null : (Number.isFinite(Number(raw)) ? Number(raw) : raw);
          saveAll(); renderApp();
        };
        inp.onkeydown = (e) => { if (e.key === 'Enter') inp.blur(); };
      });

      menuPlayers.onclick = () => openPlayersModal(g);
      menuReset.onclick = () => resetGame(g.id);
    }

    // Toggle dropdown
    document.getElementById('menuBtn').addEventListener('click', e => {
      const dropdown = document.getElementById('menuDropdown');
      dropdown.classList.toggle('hidden');
    });

    // Hide menu when clicking outside
    document.addEventListener('click', e => {
      const wrap = document.querySelector('.menu-wrap');
      if (!wrap.contains(e.target)) {
        document.getElementById('menuDropdown').classList.add('hidden');
      }
    });

    menuShare.addEventListener("click", (e) => {
      e.stopPropagation();
      submenuShare.classList.toggle("hidden");
    });

    submenuShare.addEventListener("click", (e) => {
      e.stopPropagation();
      if (e.target.dataset.share) {
        const format = e.target.dataset.share;
        submenuShare.classList.add("hidden");
        menuDropdown.classList.add("hidden");
        shareAction(format);
      }
    });

    menuTemplates.addEventListener('click', () => {
      document.getElementById('menuDropdown').classList.add('hidden');
      openTemplatesModal();
    });

    menuGames.addEventListener('click', () => { openGamesModal(); });

    // --------------------------- Sharing / Export ---------------------------

    async function shareAction(format = "fixed") {
      document.getElementById('menuDropdown').classList.add('hidden');
      if (!activeGameId) { alert('Open a game first.'); return; }
      const g = findGame(activeGameId);

      if (format === "image") {
        const blob = await exportGameAsImage();
        shareOrDownloadPng(blob);
      } else {
        const text = exportGameText(g, 6, format);

        try {
          if (navigator.share) {
            await navigator.share({ text: text, title: g.title });
          } else {
            await navigator.clipboard.writeText(text);
            alert('Game text copied to clipboard.');
          }
        } catch (e) {
          await navigator.clipboard.writeText(text);
          alert('Copied to clipboard.');
        }

      }

    }

    function exportGameText(g, maxNameLen = 6, format = "fixed") {

      const labelsHeader = ".";
      const dateStr = formatDateISO(g.createdAt);
      const hdr =
        g.type === "Fixed" && g.template
          ? `${g.title}: ${dateStr} (${g.template})`
          : `${g.title}: ${dateStr}`;

      const names = g.players.map(n =>
        n.length > maxNameLen ? n.slice(0, maxNameLen) : n
      );

      const firstColWidth = g.type === "Standard" ? 2 : 2;
      const nameWidth = Math.max(...names.map(n => n.length));

      const isCSV = format === "csv";
      const isMarkdown = format === "markdown";
      const isFixed = format === "fixed";

      function pad(s, w, align = "right") {
        s = String(s);
        return align === "right" ? s.padStart(w, " ") : s.padEnd(w, " ");
      }

      function sepLine(colCount) {
        if (isCSV) return null;
        return (
          "-".repeat(firstColWidth) +
          "|" +
          Array(colCount).fill("-".repeat(nameWidth)).join("|")
        );
      }

      const lines = [];
      lines.push(hdr);

      // === STANDARD GAME TYPE ===
      if (g.type === "Standard") {
        const rounds = g.rounds || [];

        if (isFixed && sepLine(names.length)) lines.push(sepLine(names.length));

        // Header row
        if (isCSV) {
          lines.push([labelsHeader, ...names].join(","));
        } else {
          const headerRow =
            pad(labelsHeader, firstColWidth, "right") + "|" + names.map(n => pad(n, nameWidth)).join("|");
          lines.push(headerRow);
          if (sepLine(names.length)) lines.push(sepLine(names.length));
        }

        // Round rows
        rounds.forEach((r, i) => {
          if (isCSV) {
            const row = [i + 1, ...names.map(n => r[n] ?? "")].join(",");
            lines.push(row);
          } else {
            const label = pad(String(i + 1), firstColWidth, "left");
            const cells = names
              .map(n => pad(r[n] ?? "", nameWidth))
              .join("|");
            lines.push(label + "|" + cells);
          }
        });

        // Totals
        const totals = names.map(n => {
          let s = 0;
          rounds.forEach(r => {
            const v = r[n];
            s += v === null || v === "" || v === undefined ? 0 : Number(v) || 0;
          });
          return s;
        });

        if (isCSV) {
          lines.push(["T", ...totals].join(","));
        } else if (isMarkdown) {
          lines.push(`**T**|${totals.map(v => `**${v}**`).join("|")}`);
        } else {
          if (sepLine(names.length)) lines.push(sepLine(names.length));
          lines.push(
            pad("T", firstColWidth, "left") +
            "|" +
            totals.map(v => pad(String(v), nameWidth)).join("|")
          );
          if (sepLine(names.length)) lines.push(sepLine(names.length));
        }
      }

      // === TALLY GAME TYPE ===
      else if (g.type === "Tally") {
        if (isFixed && sepLine(names.length)) lines.push(sepLine(names.length));

        if (isCSV) {
          lines.push([labelsHeader, ...names].join(","));
        } else {
          const header =
            pad(labelsHeader, firstColWidth) + "|" + names.map(n => pad(n, nameWidth)).join("|");
          lines.push(header);
          if (sepLine(names.length)) lines.push(sepLine(names.length));
        }

        const totals = names.map((_, idx) => (g.tally && g.tally[idx]) || 0);

        if (isCSV) {
          lines.push(["T", ...totals].join(","));
        } else if (isMarkdown) {
          lines.push(`**T**|${totals.map(v => `**${v}**`).join("|")}`);
        } else {
          lines.push(
            pad("T", firstColWidth, "left") +
            "|" +
            totals.map(v => pad(String(v), nameWidth)).join("|")
          );
          if (sepLine(names.length)) lines.push(sepLine(names.length));
        }
      }

      // === FIXED GAME TYPE ===
      else if (g.type === "Fixed") {
        if (isFixed && sepLine(names.length)) lines.push(sepLine(names.length));

        if (isCSV) {
          lines.push([labelsHeader, ...names].join(","));
        } else {
          const headerRow =
            pad(labelsHeader, firstColWidth, "right") +
            "|" +
            names
              .map(n => {
                const padLeft = Math.floor((nameWidth - n.length) / 2);
                const padRight = nameWidth - n.length - padLeft;
                return " ".repeat(padLeft) + n + " ".repeat(padRight);
              })
              .join("|");
          lines.push(headerRow);
          if (sepLine(names.length)) lines.push(sepLine(names.length));
        }

        g.rows.forEach(r => {
          if (isCSV) {
            const row = [r.label, ...r.vals].join(",");
            lines.push(row);
          } else {
            const label = pad(r.label, firstColWidth, "left");
            const cells = r.vals
              .map(v => pad(v === null || v === undefined ? "" : String(v), nameWidth))
              .join("|");
            lines.push(label + "|" + cells);
          }
        });

        const totals = names.map((_, idx) => {
          let s = 0;
          g.rows.forEach(r => {
            const v = r.vals[idx];
            s += v === null || v === "" || v === undefined ? 0 : Number(v) || 0;
          });
          return s;
        });

        if (isCSV) {
          lines.push(["T", ...totals].join(","));
        } else if (isMarkdown) {
          lines.push(`**T**|${totals.map(v => `**${v}**`).join("|")}`);
        } else {
          if (sepLine(names.length)) lines.push(sepLine(names.length));
          lines.push(
            pad("T", firstColWidth, "left") +
            "|" +
            totals.map(v => pad(String(v), nameWidth)).join("|")
          );
          if (sepLine(names.length)) lines.push(sepLine(names.length));
        }
      }

      // === OTHER TYPES ===
      else {
        lines.push("No export for this type");
      }

      // Wrap in backticks for "fixed" format
      let out = lines.join("\n");
      if (isFixed) out = "```\n" + out + "\n```";

      return out;
    }

    async function exportGameAsImage(selector = "#app", hideSelectors = [".button", ".btn", ".menu-btn", ".add-row", ".remove-row"]) {
      const container = document.querySelector(selector);
      if (!container) throw new Error(`Container not found: ${selector}`);

      // Hide elements before capture
      const hidden = [];
      hideSelectors.forEach(sel => {
        document.querySelectorAll(sel).forEach(el => {
          hidden.push([el, el.style.display]);
          el.style.display = "none";
        });
      });

      // Use html2canvas to render full content
      const canvas = await html2canvas(container, {
        backgroundColor: null,
        useCORS: true,
        scrollX: 0,
        scrollY: -window.scrollY, // capture full view if scrolled
        windowWidth: document.documentElement.scrollWidth,
        windowHeight: document.documentElement.scrollHeight,
      });

      // Restore hidden elements
      hidden.forEach(([el, prev]) => (el.style.display = prev));

      // Return PNG blob
      return new Promise(resolve => canvas.toBlob(resolve, "image/png"));
    }


    async function shareOrDownloadPng(pngBlob, filename = 'game.png') {
      try {
        // Check if Web Share API supports file sharing
        if (navigator.canShare && navigator.canShare({ files: [new File([pngBlob], filename, { type: 'image/png' })] })) {
          const file = new File([pngBlob], filename, { type: 'image/png' });
          await navigator.share({
            title: 'Game Export',
            text: 'Here is the game export image.',
            files: [file],
          });
          // console.log('Shared successfully!');
        } else {
          // Fallback: trigger download
          const url = URL.createObjectURL(pngBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          // console.log('Downloaded as file:', filename);
        }
      } catch (err) {
        console.error('Error sharing or downloading PNG:', err);
        // Always provide fallback on error
        const url = URL.createObjectURL(pngBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
    }

    // --------------------------- Helpers ---------------------------
    function escapeHtml(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

    // load initial active game if any
    if (activeGameId) {
      setActiveGame(activeGameId);
    }
    else if (games.length > 0) {
      setActiveGame(games[0].id);
    } else {
      // create a default new game placeholder but do not save to list until user creates
      activeGameId = null;
      renderApp();
    }

    // small keyboard shortcuts for convenience (desktop)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'g' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); openGamesModal(); }
    });

    // small autosave on visibility change
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') saveAll(); });

  </script>
</body>

</html>